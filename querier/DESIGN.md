To align with your request to craft a design spec for the CS50 TSE Querier based on the structure provided, I've tailored a design spec that reflects the necessary components for the Querier module. This spec outlines the user interface, inputs and outputs, functional decomposition, pseudo code for logic flow, major data structures, and a testing plan, drawing parallels from the example you provided for the Indexer.

---

# CS50 TSE Querier
## Design Spec

This document, drawing from the [Requirements Specification](REQUIREMENTS.md), delineates the design decisions for the TSE Querier module, emphasizing implementation-independent considerations.

## User Interface

The Querier interfaces with users via the command line, requiring two arguments: the path to a directory produced by `crawler` and the path to an index file generated by `indexer`.

```bash
$ ./querier pageDirectory indexFilename
```

For instance, querying a directory and index file stored in `../data/letters-10`:

```bash
$ ./querier ../data/letters-10 ../data/letters-10/index.ndx
```

Preparation involves invoking `crawler` and `indexer`:

```bash
$ mkdir ../data/letters-10
$ ./crawler http://cs50tse.cs.dartmouth.edu/tse/letters/index.html ../data/letters-10 10
$ ./indexer ../data/letters-10 ../data/letters-10.index
```

### Inputs and Outputs

**Input**: Querier accepts queries from stdin, supporting both interactive (tty) and file-based inputs. Queries are processed line by line.

**Output**: Outputs the sanitized query and a ranked list of documents (docID and score), adhering to requirements specified in `REQUIREMENTS.md`.

### Functional Decomposition into Modules

Querier's functionality is divided among several modules:

1. **main**: Parses command-line arguments, validates inputs, and orchestrates other modules.
2. **query**: Handles query processing, including parsing, validation, and ranking.
3. **parse_query**: Normalizes and tokenizes input queries.
4. **verify_query**: Validates query syntax and constraints.
5. **parse_words**: Splits query into words based on whitespace.

Helper modules:

1. **index**: Manages the in-memory index structure and functions for index file reading.
2. **word**: Provides functionality for word normalization and processing.
3. **file**: Offers utilities for reading from stdin and files.
4. **mem**: Includes wrapper functions for memory allocation and deallocation.

### Pseudo Code for Logic/Algorithmic Flow

**Querier Operation:**

    Initialize and validate command-line arguments.
    Loop through stdin for queries:
        Normalize and tokenize query.
        Validate query syntax.
        If valid, search index and rank documents.
    Cleanup and exit.

**Query Processing:**
    Delimit query into words
    Normalize words to lowercase.
    Tokenize query into words.
    Validate query structure.
    Search index for words, rank documents.

**Query Validation:**

    Ensure no disallowed characters.
    Check for logical ordering of operators (AND, OR).
    Verify no adjacent operators without intervening words.

### Major Data Structures

The primary data structure is the **index**, a hashtable mapping words to counters, which in turn map document IDs to occurrence counts. This structure efficiently supports the retrieval and ranking of documents based on query terms.

### Testing Plan

**Integration Testing:**

1. **Argument Validation**: Test with various argument combinations to ensure robust error handling.
    - Missing or extra arguments.
    - Invalid `pageDirectory` or `indexFilename` paths.

2. **Query Processing**: Run queries on different datasets 

3. **Memory and Error Checking**: Use Valgrind to confirm no memory leaks or errors occur during execution.

By following this design spec, the Querier module aims to provide a reliable and efficient means for querying the indexed data, ensuring an intuitive user interface and accurate search results.